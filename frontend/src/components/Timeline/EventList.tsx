/**
 * EventList - Main event browsing interface
 */

import { useState, useEffect } from 'react';
import { EventType } from '@/types/timeline';
import { timelineApi } from '@/lib/api';
import { useTimelineStore } from '@/stores/timelineStore';
import { useCodexStore } from '@/stores/codexStore';
import { toast } from '@/stores/toastStore';
import { confirm } from '@/stores/confirmStore';
import EventCard from './EventCard';
import EventDetail from './EventDetail';

interface EventListProps {
  manuscriptId: string;
}

export default function EventList({ manuscriptId }: EventListProps) {
  const {
    events,
    setEvents,
    selectedEventId,
    setSelectedEvent,
  } = useTimelineStore();
  const { entities } = useCodexStore();

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [filterType, setFilterType] = useState<EventType | 'ALL'>('ALL');
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [creating, setCreating] = useState(false);
  const [analyzing, setAnalyzing] = useState(false);
  const [analysisProgress, setAnalysisProgress] = useState('');

  // Create form state
  const [newEventDesc, setNewEventDesc] = useState('');
  const [newEventType, setNewEventType] = useState<EventType>(EventType.SCENE);
  const [newEventTimestamp, setNewEventTimestamp] = useState('');
  const [newEventCharacterIds, setNewEventCharacterIds] = useState<string[]>([]);

  // Get available characters from Codex
  const availableCharacters = entities.filter((e) => e.type === 'CHARACTER');

  // Load events on mount
  useEffect(() => {
    loadEvents();
  }, [manuscriptId]);

  const loadEvents = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await timelineApi.listEvents(manuscriptId);
      setEvents(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load events');
    } finally {
      setLoading(false);
    }
  };

  const handleCreateEvent = async () => {
    if (!newEventDesc.trim()) {
      setError('Event description is required');
      return;
    }

    try {
      setCreating(true);
      setError(null);

      const event = await timelineApi.createEvent({
        manuscript_id: manuscriptId,
        description: newEventDesc.trim(),
        event_type: newEventType,
        timestamp: newEventTimestamp.trim() || undefined,
        character_ids: newEventCharacterIds.length > 0 ? newEventCharacterIds : undefined,
      });

      // Add to store
      setEvents([...events, event]);

      // Reset form
      setNewEventDesc('');
      setNewEventType(EventType.SCENE);
      setNewEventTimestamp('');
      setNewEventCharacterIds([]);
      setShowCreateForm(false);

      // Select new event
      setSelectedEvent(event.id);
    } catch (err) {
      setError('Failed to create event: ' + (err instanceof Error ? err.message : 'Unknown error'));
    } finally {
      setCreating(false);
    }
  };

  const handleDeleteEvent = async (eventId: string) => {
    if (!(await confirm({ title: 'Delete Event', message: 'Delete this event? This cannot be undone.', variant: 'danger', confirmLabel: 'Delete' }))) {
      return;
    }

    try {
      await timelineApi.deleteEvent(eventId);
      setEvents(events.filter((e) => e.id !== eventId));
      if (selectedEventId === eventId) {
        setSelectedEvent(null);
      }
    } catch (err) {
      toast.error('Failed to delete event: ' + (err instanceof Error ? err.message : 'Unknown error'));
    }
  };

  const handleExtractTimeline = async () => {
    console.log('üîç Extract Timeline clicked');

    // Check for existing events
    const autoGeneratedCount = events.filter(e => e.event_metadata?.auto_generated).length;
    const unmarkedCount = events.filter(e => !e.event_metadata?.auto_generated).length;
    const totalCount = events.length;

    console.log(`üìä Events: ${totalCount} total, ${autoGeneratedCount} auto-generated, ${unmarkedCount} unmarked`);

    let shouldClearEvents = false;

    if (totalCount > 0) {
      // If there are unmarked events (old events from before the auto_generated flag)
      if (unmarkedCount > 0) {
        shouldClearEvents = await confirm({
          title: 'Clear Events?',
          message: `Found ${totalCount} existing event(s): ${autoGeneratedCount} auto-generated, ${unmarkedCount} from before tracking was added. Clear ALL events and re-extract fresh?`,
          variant: 'warning',
          confirmLabel: 'Clear & Re-extract',
        });
      } else if (autoGeneratedCount > 0) {
        // All events are marked as auto-generated
        shouldClearEvents = await confirm({
          title: 'Clear Events?',
          message: `Found ${autoGeneratedCount} auto-generated event(s) from previous extractions. Clear them and re-extract fresh?`,
          variant: 'warning',
          confirmLabel: 'Clear & Re-extract',
        });
      }
    } else {
      // No existing events, just confirm extraction
      if (!(await confirm({ title: 'Extract Timeline', message: 'This will analyze your manuscript and automatically create timeline events. Continue?', variant: 'info', confirmLabel: 'Extract' }))) {
        return;
      }
    }

    console.log(`üöÄ Starting extraction, shouldClearEvents: ${shouldClearEvents}`);

    try {
      setAnalyzing(true);
      setError(null);

      // Clear events if user chose to
      if (shouldClearEvents) {
        setAnalysisProgress('Clearing old events...');
        if (unmarkedCount > 0) {
          // Clear ALL events (includes unmarked old events)
          const result = await timelineApi.deleteAllEvents(manuscriptId);
          console.log(`Cleared ${result.deleted_count} events`);
        } else {
          // Only clear auto-generated events
          const result = await timelineApi.deleteAutoGeneratedEvents(manuscriptId);
          console.log(`Cleared ${result.deleted_count} auto-generated events`);
        }
      }

      // Fetch all chapters for this manuscript
      const chaptersResponse = await fetch(`http://localhost:8000/api/chapters/manuscript/${manuscriptId}/tree`);
      if (!chaptersResponse.ok) {
        throw new Error('Failed to fetch chapters');
      }

      const chaptersData = await chaptersResponse.json();

      // Recursively collect all non-folder chapters
      const collectChapters = (nodes: any[]): any[] => {
        let chapters: any[] = [];
        for (const node of nodes) {
          if (!node.is_folder) {
            chapters.push(node);
          }
          if (node.children && node.children.length > 0) {
            chapters = chapters.concat(collectChapters(node.children));
          }
        }
        return chapters;
      };

      const allChapters = collectChapters(chaptersData.data || []);

      if (allChapters.length === 0) {
        setError('No chapters found in this manuscript');
        setAnalyzing(false);
        return;
      }

      // Fetch and analyze each chapter separately (tracks chapter_id)
      let processedCount = 0;

      for (let i = 0; i < allChapters.length; i++) {
        const chapter = allChapters[i];
        setAnalysisProgress(`Analyzing chapter ${i + 1}/${allChapters.length}: ${chapter.title}`);

        try {
          const chapterResponse = await fetch(`http://localhost:8000/api/chapters/${chapter.id}`);
          if (chapterResponse.ok) {
            const chapterData = await chapterResponse.json();
            const content = chapterData.data.content || '';

            if (content.trim()) {
              // Analyze this chapter individually with chapter_id tracking
              await timelineApi.analyzeTimeline({
                manuscript_id: manuscriptId,
                text: content,
                chapter_id: chapter.id,  // Track which chapter this came from
              });
              processedCount++;
            }
          }
        } catch (err) {
          console.error(`Failed to analyze chapter ${chapter.id}:`, err);
        }
      }

      if (processedCount === 0) {
        setError('No content found in manuscript chapters');
        setAnalyzing(false);
        return;
      }

      console.log(`Analyzed ${processedCount} chapters`);

      setAnalysisProgress('Extracting events...');

      // Wait for background processing - proportional to content size
      // The backend needs time to process each chunk with rate limiting (1s between API calls)
      // Minimum 10 seconds, plus 5 seconds per chapter analyzed
      const waitTime = Math.max(10000, processedCount * 5000);
      console.log(`Waiting ${waitTime}ms for background extraction to complete...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));

      // Reload events
      setAnalysisProgress('Loading timeline...');
      await loadEvents();

      // Show success message
      setAnalysisProgress('');
      toast.success(`Timeline extraction complete! Analyzed ${processedCount} chapter(s). Check the Visual tab to see your timeline.`);
    } catch (err) {
      setError('Failed to analyze timeline: ' + (err instanceof Error ? err.message : 'Unknown error'));
    } finally {
      setAnalyzing(false);
      setAnalysisProgress('');
    }
  };

  // Filter events by type
  const filteredEvents = events.filter((event) => {
    return filterType === 'ALL' || event.event_type === filterType;
  });

  // Sort by order_index
  const sortedEvents = [...filteredEvents].sort((a, b) => a.order_index - b.order_index);

  // Get selected event
  const selectedEvent = selectedEventId
    ? events.find((e) => e.id === selectedEventId)
    : null;

  if (loading) {
    return (
      <div className="flex flex-col items-center justify-center p-8 gap-3">
        <div className="w-8 h-8 border-4 border-bronze border-t-transparent rounded-full animate-spin"></div>
        <p className="text-faded-ink font-sans text-sm">Loading timeline...</p>
      </div>
    );
  }

  if (error && events.length === 0) {
    return (
      <div className="p-4">
        <div className="bg-redline/10 border-l-4 border-redline p-3 text-sm font-sans text-redline">
          {error}
        </div>
        <button
          onClick={loadEvents}
          className="mt-2 text-sm font-sans text-bronze hover:underline"
        >
          Retry
        </button>
      </div>
    );
  }

  // If event is selected, show detail view
  if (selectedEvent) {
    return (
      <EventDetail
        event={selectedEvent}
        onClose={() => setSelectedEvent(null)}
        onUpdate={loadEvents}
      />
    );
  }

  return (
    <div className="flex flex-col h-full">
      {/* Header with Create and Extract Buttons */}
      <div className="p-4 border-b border-slate-ui space-y-2">
        <button
          onClick={() => setShowCreateForm(!showCreateForm)}
          className="w-full bg-bronze text-white px-4 py-2 text-sm font-sans hover:bg-bronze/90 transition-colors"
          style={{ borderRadius: '2px' }}
        >
          + Create Event
        </button>
        <button
          onClick={handleExtractTimeline}
          disabled={analyzing}
          className="w-full bg-white border border-bronze text-bronze px-4 py-2 text-sm font-sans hover:bg-bronze/10 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          style={{ borderRadius: '2px' }}
        >
          {analyzing ? (
            <div className="flex flex-col items-center gap-2">
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 border-2 border-bronze border-t-transparent rounded-full animate-spin"></div>
                <span>Extracting Timeline...</span>
              </div>
              {analysisProgress && (
                <div className="text-xs text-faded-ink">{analysisProgress}</div>
              )}
            </div>
          ) : (
            <span>üîç Extract Timeline</span>
          )}
        </button>
      </div>

      {/* Create Form */}
      {showCreateForm && (
        <div className="p-4 bg-white border-b border-slate-ui">
          <h3 className="font-garamond font-semibold text-midnight mb-3">New Event</h3>

          {error && (
            <div className="mb-3 bg-redline/10 border-l-4 border-redline p-2 text-xs font-sans text-redline">
              {error}
            </div>
          )}

          <div className="space-y-3">
            <div>
              <label className="block text-xs font-sans text-faded-ink uppercase mb-1">
                Description
              </label>
              <textarea
                value={newEventDesc}
                onChange={(e) => {
                  setNewEventDesc(e.target.value);
                  setError(null);
                }}
                placeholder="What happens in this event?"
                className="w-full bg-white border border-slate-ui px-3 py-2 text-sm font-serif min-h-[80px]"
                style={{ borderRadius: '2px' }}
                autoFocus
                disabled={creating}
              />
            </div>

            <div>
              <label className="block text-xs font-sans text-faded-ink uppercase mb-1">
                Type
              </label>
              <select
                value={newEventType}
                onChange={(e) => setNewEventType(e.target.value as EventType)}
                className="w-full bg-white border border-slate-ui px-3 py-2 text-sm font-sans"
                style={{ borderRadius: '2px' }}
                disabled={creating}
              >
                <option value={EventType.SCENE}>Scene</option>
                <option value={EventType.CHAPTER}>Chapter</option>
                <option value={EventType.FLASHBACK}>Flashback</option>
                <option value={EventType.DREAM}>Dream</option>
                <option value={EventType.MONTAGE}>Montage</option>
              </select>
            </div>

            <div>
              <label className="block text-xs font-sans text-faded-ink uppercase mb-1">
                Timestamp (optional)
              </label>
              <input
                type="text"
                value={newEventTimestamp}
                onChange={(e) => setNewEventTimestamp(e.target.value)}
                placeholder="e.g., Day 3, Morning"
                className="w-full bg-white border border-slate-ui px-3 py-2 text-sm font-sans"
                style={{ borderRadius: '2px' }}
                disabled={creating}
              />
            </div>

            {/* Characters */}
            <div>
              <label className="block text-xs font-sans text-faded-ink uppercase mb-1">
                Characters (optional)
              </label>
              {availableCharacters.length === 0 ? (
                <p className="text-xs text-faded-ink font-sans py-2">
                  No characters in Codex yet. Create characters first to link them to events.
                </p>
              ) : (
                <div className="bg-white border border-slate-ui p-2 max-h-32 overflow-y-auto" style={{ borderRadius: '2px' }}>
                  {availableCharacters.map((char) => (
                    <label key={char.id} className="flex items-center gap-2 py-1 hover:bg-vellum cursor-pointer">
                      <input
                        type="checkbox"
                        checked={newEventCharacterIds.includes(char.id)}
                        onChange={(e) => {
                          if (e.target.checked) {
                            setNewEventCharacterIds([...newEventCharacterIds, char.id]);
                          } else {
                            setNewEventCharacterIds(newEventCharacterIds.filter((id) => id !== char.id));
                          }
                        }}
                        className="text-bronze"
                        disabled={creating}
                      />
                      <span className="text-sm font-sans text-midnight">{char.name}</span>
                    </label>
                  ))}
                </div>
              )}
            </div>

            <div className="flex gap-2">
              <button
                onClick={handleCreateEvent}
                disabled={creating}
                className="flex-1 bg-bronze text-white px-3 py-2 text-sm font-sans hover:bg-bronze/90 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                style={{ borderRadius: '2px' }}
              >
                {creating && <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>}
                {creating ? 'Creating...' : 'Create'}
              </button>
              <button
                onClick={() => {
                  setShowCreateForm(false);
                  setNewEventDesc('');
                  setNewEventTimestamp('');
                  setNewEventCharacterIds([]);
                  setError(null);
                }}
                disabled={creating}
                className="flex-1 bg-slate-ui text-midnight px-3 py-2 text-sm font-sans hover:bg-slate-ui/80 disabled:opacity-50 disabled:cursor-not-allowed"
                style={{ borderRadius: '2px' }}
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Filter Tabs */}
      <div className="flex border-b border-slate-ui overflow-x-auto bg-white">
        {['ALL', ...Object.values(EventType)].map((type) => (
          <button
            key={type}
            onClick={() => setFilterType(type as EventType | 'ALL')}
            className={`
              px-4 py-2 text-sm font-sans whitespace-nowrap transition-colors
              ${filterType === type
                ? 'text-bronze border-b-2 border-bronze'
                : 'text-faded-ink hover:text-midnight'
              }
            `}
          >
            {type}
            <span className="ml-1 text-xs">
              ({type === 'ALL' ? events.length : events.filter((e) => e.event_type === type).length})
            </span>
          </button>
        ))}
      </div>

      {/* Event List */}
      <div className="flex-1 overflow-y-auto p-4">
        {sortedEvents.length === 0 ? (
          <div className="flex flex-col items-center justify-center p-8 text-center">
            <div className="text-4xl mb-3">üé¨</div>
            <p className="text-midnight font-garamond font-semibold mb-2">
              No {filterType === 'ALL' ? 'events' : filterType.toLowerCase() + 's'} yet
            </p>
            <p className="text-sm text-faded-ink font-sans max-w-xs">
              Create events manually or use the "Extract Timeline" button to analyze your manuscript
            </p>
          </div>
        ) : (
          <div className="space-y-3">
            {sortedEvents.map((event) => (
              <EventCard
                key={event.id}
                event={event}
                isSelected={selectedEventId === event.id}
                onSelect={() => setSelectedEvent(event.id)}
                onDelete={() => handleDeleteEvent(event.id)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
