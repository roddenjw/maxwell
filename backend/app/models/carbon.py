"""
Carbon Footprint Tracking models

Implements Software Carbon Intensity (SCI) methodology from the
Green Software Foundation for tracking and minimizing environmental impact.

SCI = ((E × I) + M) / R
Where:
- E = Energy consumed (kWh)
- I = Carbon intensity of electricity (gCO2eq/kWh)
- R = Functional unit (per user, per request, etc.)
- M = Embodied carbon of hardware
"""

from sqlalchemy import Column, String, Text, DateTime, Integer, Float, ForeignKey, JSON
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid

from app.database import Base


class CarbonMetric(Base):
    """
    Individual carbon emission records for operations.

    Each significant operation (AI call, heavy computation, etc.) gets tracked
    to enable carbon footprint analysis and optimization.
    """
    __tablename__ = "carbon_metrics"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))

    # Operation identification
    operation_type = Column(String, nullable=False)  # 'ai_request', 'db_query', 'storage_write', etc.
    operation_subtype = Column(String, nullable=True)  # More specific: 'grammar_check', 'plot_analysis'

    # Context (optional - for per-manuscript tracking)
    manuscript_id = Column(String, ForeignKey("manuscripts.id"), nullable=True)

    # Energy metrics (in micro units for precision without floats)
    energy_micro_kwh = Column(Integer, default=0)  # Energy in micro-kWh (1M = 1 kWh)

    # Carbon intensity of the grid at time of operation
    carbon_intensity = Column(Integer, default=400)  # gCO2eq/kWh (default: global average)
    region = Column(String, default="unknown")  # Geographic region for grid intensity

    # Calculated emissions
    emissions_micro_gco2 = Column(Integer, default=0)  # Emissions in micro-gCO2eq

    # Operation-specific metrics
    tokens_processed = Column(Integer, default=0)  # For AI operations
    bytes_transferred = Column(Integer, default=0)  # For network/storage
    compute_ms = Column(Integer, default=0)  # Compute time in milliseconds

    # Model/provider info for AI operations
    ai_provider = Column(String, nullable=True)
    ai_model = Column(String, nullable=True)

    # Was this operation optimized?
    cache_hit = Column(Integer, default=0)  # 1 if served from cache
    batched = Column(Integer, default=0)  # 1 if part of a batch
    deferred = Column(Integer, default=0)  # 1 if carbon-aware scheduled

    # Timestamp
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    def __repr__(self):
        return f"<CarbonMetric(type={self.operation_type}, emissions={self.emissions_micro_gco2}µgCO2)>"


class CarbonReport(Base):
    """
    Aggregated carbon reports for dashboards and analysis.

    Generated periodically to show trends and identify optimization opportunities.
    """
    __tablename__ = "carbon_reports"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))

    # Report period
    period_start = Column(DateTime, nullable=False)
    period_end = Column(DateTime, nullable=False)
    period_type = Column(String, default="daily")  # 'hourly', 'daily', 'weekly', 'monthly'

    # Scope (optional - for per-manuscript reports)
    manuscript_id = Column(String, ForeignKey("manuscripts.id"), nullable=True)

    # Aggregated metrics
    total_energy_micro_kwh = Column(Integer, default=0)
    total_emissions_micro_gco2 = Column(Integer, default=0)

    # Breakdown by operation type (JSON)
    emissions_breakdown = Column(JSON, default=dict)
    # Example: {"ai_operations": 5000000, "storage": 100000, "compute": 50000}

    # SCI score (Software Carbon Intensity)
    sci_score = Column(Float, default=0.0)  # gCO2eq per functional unit
    functional_unit = Column(String, default="per_request")  # What R represents
    functional_unit_count = Column(Integer, default=0)

    # Optimization metrics
    cache_hit_rate = Column(Float, default=0.0)  # Percentage
    requests_batched = Column(Integer, default=0)
    requests_deferred = Column(Integer, default=0)
    estimated_savings_micro_gco2 = Column(Integer, default=0)

    # Trend indicator
    trend = Column(String, default="stable")  # 'improving', 'stable', 'worsening'
    previous_period_emissions = Column(Integer, default=0)

    # Recommendations (generated by analysis)
    recommendations = Column(JSON, default=list)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    def __repr__(self):
        return f"<CarbonReport(period={self.period_type}, sci={self.sci_score})>"


class CarbonBudget(Base):
    """
    Optional carbon budgets that can be set per manuscript or globally.

    Helps authors track and limit their environmental impact.
    """
    __tablename__ = "carbon_budgets"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))

    # Scope
    manuscript_id = Column(String, ForeignKey("manuscripts.id"), nullable=True)  # null = global

    # Budget settings
    budget_period = Column(String, default="monthly")  # 'daily', 'weekly', 'monthly'
    budget_micro_gco2 = Column(Integer, default=0)  # Budget in micro-gCO2eq

    # Current usage in this period
    current_usage_micro_gco2 = Column(Integer, default=0)
    period_start = Column(DateTime, nullable=False)

    # Alert thresholds (percentage of budget)
    warn_threshold = Column(Integer, default=80)  # Warn at 80%
    limit_threshold = Column(Integer, default=100)  # Limit at 100%

    # What to do when limit is reached
    limit_action = Column(String, default="warn")  # 'warn', 'defer', 'block'

    # Is the budget active?
    is_active = Column(Integer, default=1)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<CarbonBudget(budget={self.budget_micro_gco2}µgCO2, usage={self.current_usage_micro_gco2})>"


# Constants for energy estimation
ENERGY_ESTIMATES_MICRO_KWH = {
    # AI Operations (per 1K tokens) - highest impact
    "ai_request_small": 100,    # ~0.0001 kWh per 1K tokens (Haiku-class)
    "ai_request_medium": 250,   # ~0.00025 kWh per 1K tokens (Sonnet-class)
    "ai_request_large": 400,    # ~0.0004 kWh per 1K tokens (Opus-class)

    # Database Operations (per operation)
    "db_read_simple": 0.1,      # Simple SELECT
    "db_read_complex": 1,       # JOIN, aggregation
    "db_write": 0.5,            # INSERT/UPDATE

    # Storage Operations (per MB)
    "storage_read_mb": 0.01,
    "storage_write_mb": 0.05,

    # Network (per MB transferred)
    "network_transfer_mb": 0.06,

    # NLP Processing (per 1K words)
    "nlp_analysis": 10,
}

# Regional carbon intensity (gCO2eq/kWh) - 2025 estimates
CARBON_INTENSITY_BY_REGION = {
    # Low carbon (renewables)
    "eu-north-1": 50,      # Stockholm - hydro
    "eu-west-1": 300,      # Ireland - wind
    "us-west-2": 350,      # Oregon - hydro mix

    # Medium carbon
    "us-east-1": 400,      # Virginia
    "eu-central-1": 400,   # Frankfurt

    # Higher carbon
    "ap-south-1": 700,     # Mumbai - coal heavy
    "ap-southeast-1": 500, # Singapore

    # Default (global average)
    "unknown": 400,
}
